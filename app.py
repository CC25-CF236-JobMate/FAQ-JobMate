from flask import Flask, request, jsonify
from flask_cors import CORS
import json
import re
import torch
from transformers import AutoTokenizer, AutoModel
import faiss
import numpy as np
from sklearn.preprocessing import normalize
import random
import os
import google.generativeai as genai

## Konfigurasi banyak API Key dari environment variable
API_KEYS = [
    os.environ.get("GOOGLE_API_KEY_1"),
    os.environ.get("GOOGLE_API_KEY_2"),
    os.environ.get("GOOGLE_API_KEY_3"),
    os.environ.get("GOOGLE_API_KEY_4"),
    os.environ.get("GOOGLE_API_KEY_5"),
    os.environ.get("GOOGLE_API_KEY_6")
]
api_key_index = 0  # global penanda round-robin

def get_gemini_model(api_key):
    genai.configure(api_key=api_key)
    return genai.GenerativeModel('gemini-1.5-flash')

app = Flask(__name__)
CORS(app)

def preprocess_text(text):
    text = text.lower()
    text = re.sub(r'[^\w\s]', '', text)
    text = re.sub(r'\s+', ' ', text).strip()
    return text

# Load IndoBERT model & tokenizer sekali saat startup
print("Loading IndoBERT model...")
model_name = "indolem/indobert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModel.from_pretrained(model_name)
model.eval()
print("Model loaded.")

# Load dataset FAQ
print("Loading and processing FAQ dataset...")
with open("dataset/qnaJobMate.json", "r", encoding="utf-8") as f:
    data = json.load(f)

all_questions = []
all_answers = []
all_original_questions = []

for item in data:
    question_variants = [item['question']] + item.get('paraphrases', [])
    processed_variants = [preprocess_text(q) for q in question_variants]
    answer_variants = [item['answer']] + item.get('answer_paraphrases', [])
    for i, q_proc in enumerate(processed_variants):
        all_questions.append(q_proc)
        all_answers.append(answer_variants)
        all_original_questions.append(question_variants[i])

print("Dataset processed.")

def encode(text_list):
    embeddings = []
    with torch.no_grad():
        for text in text_list:
            inputs = tokenizer(text, return_tensors="pt", truncation=True, padding=True, max_length=64)
            outputs = model(**inputs)
            cls_embedding = outputs.last_hidden_state[:, 0, :].numpy()
            embeddings.append(cls_embedding[0])
    embeddings = np.array(embeddings)
    embeddings = normalize(embeddings)
    return embeddings

print("Encoding FAQ questions for Faiss index...")
question_embeddings = encode(all_questions)
dimension = question_embeddings.shape[1]
index = faiss.IndexFlatIP(dimension)
index.add(question_embeddings)
print("Faiss index created successfully.")

def ask_gemini(question, context=""):
    # Round-robin API key: setiap pertanyaan pakai key berbeda
    global api_key_index
    prompt = f"""
    Anda adalah JobMate Assistant, chatbot ramah untuk platform pencari kerja JobMate. Tugas Anda adalah menjawab pertanyaan pengguna hanya berdasarkan fitur JobMate berikut:
    - Pencarian lowongan: Filter nama lowongan, perusahaan, kota, tipe pekerjaan di halaman 'Lowongan'.
    - Pencarian perusahaan: Filter nama perusahaan, kota, jumlah lowongan di halaman 'Perusahaan'.
    - Rekomendasi pekerjaan: Di halaman 'Rekomendasi', pastikan profil diisi (soft skill, hard skill) untuk akurasi.
    - CV Review: Upload CV di halaman 'CV Review' untuk analisis instan.
    - Edit profil: Tambah/edit info pribadi (email, no hp, kota, nama, medsos), pendidikan, pengalaman, skill, portfolio, dokumen CV, sertifikat, preferensi pekerjaan.
    - Create CV: Buat CV ATS-friendly via menu 'Create CV' di dropdown profil.
    - Fitur AI Interview dan Job Modul: Masih dalam pengembangan.
    - Login: Wajib untuk akses semua fitur; tanpa login, hanya lihat lowongan dan perusahaan.
    Jawab dalam bahasa Indonesia yang santai, jelas, dan bersahabat. Jika pertanyaan tidak relevan dengan fitur JobMate, katakan bahwa Anda hanya bisa menjawab tentang fitur platform. Gunakan konteks berikut jika relevan: "{context}"
    Pertanyaan pengguna: "{question}"
    Jawaban Anda:
    """
    for _ in range(len(API_KEYS)):
        api_key = API_KEYS[api_key_index % len(API_KEYS)]
        api_key_index = (api_key_index + 1) % len(API_KEYS)
        if not api_key:
            continue
        try:
            gemini_model = get_gemini_model(api_key)
            response = gemini_model.generate_content(prompt)
            return response.text, f"Generated by Gemini (key: {api_key[:6]}...)"
        except Exception as e:
            app.logger.error(f"Error Gemini API key {api_key[:6]}: {e}")
            continue
    return "Maaf, fitur AI canggih sedang tidak tersedia saat ini.", "N/A"

def chatbot_response(user_question, threshold=0.8, top_k=1):
    processed_question = preprocess_text(user_question)
    user_emb = encode([processed_question])
    D, I = index.search(user_emb, top_k)
    best_idx = I[0][0]
    confidence = D[0][0]

    if confidence >= threshold:
        possible_answers = all_answers[best_idx]
        response = random.choice(possible_answers)
        return response, float(confidence), "faiss_retrieval"
    else:
        context_answer = random.choice(all_answers[best_idx])
        original_question_context = all_original_questions[best_idx]
        full_context = f"Pengguna mungkin bertanya tentang '{original_question_context}', yang jawabannya adalah: '{context_answer}'"
        response, source = ask_gemini(user_question, context=full_context)
        return response, float(confidence), source

@app.route("/faq", methods=["POST"])
def faq():
    data = request.get_json()
    question = data.get("question", "")
    if not question:
        return jsonify({"error": "Missing 'question' field"}), 400
    try:
        answer, confidence, source = chatbot_response(question)
        return jsonify({
            "answer": answer,
            "confidence": confidence,
            "source": source
        })
    except Exception as e:
        app.logger.error(f"Error processing question: {e}")
        return jsonify({"error": "Internal Server Error"}), 500

@app.route("/health", methods=["GET"])
def health_check():
    return jsonify({"status": "ok"}), 200

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080)